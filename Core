import spacy
import re
from spacy.matcher import Matcher
from spacy.util import filter_spans
from difflib import SequenceMatcher

class AdvancedUserIntentParser:
    """Advanced intent parser using spaCy NLP with full modification support"""
    
    def __init__(self):
        # Load spaCy model
        try:
            self.nlp = spacy.load("en_core_web_sm")
        except OSError:
            print("‚ùå spaCy model not found. Install with: python -m spacy download en_core_web_sm")
            # Fallback to basic tokenizer
            self.nlp = spacy.blank("en")
        
        self.matcher = Matcher(self.nlp.vocab)
        self._setup_patterns()
        
        # Test case ID patterns
        self.tc_id_pattern = r'TC_\d{3}'
        self.mod_id_pattern = r'TC_\d{3}_MODIFIED_\d+'
    
    def _setup_patterns(self):
        """Setup spaCy matcher patterns for all intents including modifications"""
        
        # Field selection patterns
        select_patterns = [
            [{"LOWER": {"IN": ["select", "choose", "pick", "use"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": "work"}, {"LOWER": {"IN": ["on", "with"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": {"IN": ["let's", "lets"]}}, {"LOWER": {"IN": ["work", "start"]}}, {"LOWER": "on", "OP": "?"}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": "i"}, {"LOWER": {"IN": ["want", "need"]}}, {"LOWER": "to", "OP": "?"}, {"LOWER": {"IN": ["work", "use"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": {"IN": ["switch", "go"]}}, {"LOWER": "to"}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": "field"}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}]
        ]
        
        # Search patterns
        search_patterns = [
            [{"LOWER": {"IN": ["search", "find", "look"]}}, {"LOWER": "for", "OP": "?"}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": "show"}, {"LOWER": "me", "OP": "?"}, {"TEXT": {"REGEX": ".*"}}, {"LOWER": "fields"}],
            [{"LOWER": {"IN": ["do", "are"]}}, {"LOWER": "you"}, {"LOWER": "have"}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": "any"}, {"TEXT": {"REGEX": ".*"}}, {"LOWER": "fields", "OP": "?"}]
        ]
        
        # List patterns
        list_patterns = [
            [{"LOWER": {"IN": ["list", "show"]}}, {"LOWER": {"IN": ["all", "everything", "options"]}}],
            [{"LOWER": "what"}, {"LOWER": {"IN": ["fields", "options"]}}, {"LOWER": {"IN": ["are", "do"]}, "OP": "?"}, {"LOWER": {"IN": ["available", "you", "we"]}, "OP": "?"}],
            [{"LOWER": {"IN": ["show", "list"]}}, {"LOWER": {"IN": ["available", "all"]}, "OP": "?"}, {"LOWER": "fields", "OP": "?"}],
            [{"LOWER": {"IN": ["what's", "whats"]}}, {"LOWER": "available"}]
        ]
        
        # Generation patterns
        generate_patterns = [
            [{"LOWER": {"IN": ["generate", "create", "make", "build"]}}],
            [{"LOWER": {"IN": ["generate", "create", "make", "build"]}}, {"LOWER": {"IN": ["test", "tests"]}, "OP": "?"}, {"LOWER": {"IN": ["cases", "case"]}, "OP": "?"}],
            [{"LOWER": {"IN": ["let's", "lets"]}}, {"LOWER": {"IN": ["start", "begin", "go"]}}],
            [{"LOWER": {"IN": ["go", "do"]}}, {"LOWER": {"IN": ["ahead", "it"]}}],
            [{"LOWER": "start"}, {"LOWER": {"IN": ["generating", "creating"]}, "OP": "?"}]
        ]
        
        # More generation patterns
        more_patterns = [
            [{"LOWER": {"IN": ["more", "additional", "extra"]}}],
            [{"LOWER": {"IN": ["generate", "create", "make"]}}, {"LOWER": "more"}],
            [{"LOWER": {"IN": ["need", "want"]}}, {"LOWER": "more"}],
            [{"LOWER": "give"}, {"LOWER": "me"}, {"LOWER": "more"}],
            [{"LOWER": {"IN": ["again", "regenerate"]}}]
        ]
        
        # Improvement/modification patterns (for new test cases or general improvements)
        improve_patterns = [
            [{"LOWER": {"IN": ["improve", "enhance", "better", "fix"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "*"}],
            [{"LOWER": {"IN": ["change", "modify", "update", "adjust"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "*"}],
            [{"LOWER": "make"}, {"TEXT": {"REGEX": ".*"}, "OP": "*"}, {"LOWER": {"IN": ["better", "different"]}}],
            [{"LOWER": {"IN": ["can", "could"]}}, {"LOWER": "you"}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": "i"}, {"LOWER": {"IN": ["want", "need"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": {"IN": ["add", "include"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}]
        ]
        
        # Specific test case modification patterns
        modify_tc_patterns = [
            # Direct TC ID modification
            [{"TEXT": {"REGEX": r"TC_\d{3}"}}, {"LOWER": {"IN": ["to", "should", "needs", "must"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "+"}],
            [{"LOWER": {"IN": ["modify", "change", "update", "fix"]}}, {"TEXT": {"REGEX": r"TC_\d{3}"}}, {"TEXT": {"REGEX": ".*"}, "OP": "*"}],
            [{"LOWER": {"IN": ["change", "modify", "update"]}}, {"LOWER": {"IN": ["the", "that"]}, "OP": "?"}, {"LOWER": {"IN": ["first", "second", "third", "last"]}}, {"LOWER": {"IN": ["test", "case"]}}],
            # Ordinal references
            [{"LOWER": {"IN": ["modify", "change", "update"]}}, {"LOWER": {"IN": ["test", "case"]}}, {"TEXT": {"REGEX": r"\d+"}}],
            [{"LOWER": {"IN": ["the", "that"]}, "OP": "?"}, {"LOWER": {"IN": ["first", "second", "third", "last"]}}, {"LOWER": {"IN": ["test", "case"]}}, {"TEXT": {"REGEX": ".*"}, "OP": "*"}]
        ]
        
        # Approve modification patterns
        approve_mod_patterns = [
            # Direct modification ID patterns
            [{"TEXT": {"REGEX": r"TC_\d{3}_MODIFIED_\d+"}}, {"LOWER": {"IN": ["approved", "accepted", "good", "ok"]}, "OP": "?"}],
            [{"LOWER": {"IN": ["approve", "accept", "yes", "keep"]}}, {"TEXT": {"REGEX": r"TC_\d{3}_MODIFIED_\d+"}}],
            [{"LOWER": {"IN": ["approve", "accept"]}}, {"LOWER": {"IN": ["the", "this"]}, "OP": "?"}, {"LOWER": {"IN": ["modification", "change", "update"]}}],
            [{"LOWER": "yes"}, {"LOWER": "to"}, {"TEXT": {"REGEX": r"TC_\d{3}_MODIFIED_\d+"}}],
            [{"LOWER": {"IN": ["looks", "look"]}}, {"LOWER": "good"}, {"TEXT": {"REGEX": r"TC_\d{3}_MODIFIED_\d+"}, "OP": "?"}],
            [{"LOWER": {"IN": ["that's", "thats"]}}, {"LOWER": {"IN": ["good", "better", "perfect"]}}]
        ]
        
        # Reject modification patterns  
        reject_mod_patterns = [
            [{"LOWER": {"IN": ["reject", "no", "discard"]}}, {"TEXT": {"REGEX": r"TC_\d{3}_MODIFIED_\d+"}}],
            [{"TEXT": {"REGEX": r"TC_\d{3}_MODIFIED_\d+"}}, {"LOWER": {"IN": ["rejected", "bad", "wrong", "no"]}}],
            [{"LOWER": "no"}, {"LOWER": "to"}, {"TEXT": {"REGEX": r"TC_\d{3}_MODIFIED_\d+"}}],
            [{"LOWER": {"IN": ["don't", "dont"]}}, {"LOWER": {"IN": ["want", "like"]}}, {"TEXT": {"REGEX": r"TC_\d{3}_MODIFIED_\d+"}}],
            [{"LOWER": {"IN": ["reject", "discard"]}}, {"LOWER": {"IN": ["the", "this"]}, "OP": "?"}, {"LOWER": {"IN": ["modification", "change"]}}],
            [{"LOWER": {"IN": ["that's", "thats"]}}, {"LOWER": {"IN": ["wrong", "bad", "terrible"]}}]
        ]
        
        # Show modifications patterns
        show_mod_patterns = [
            [{"LOWER": "show"}, {"LOWER": {"IN": ["modifications", "changes", "pending"]}}],
            [{"LOWER": {"IN": ["what", "which"]}}, {"LOWER": {"IN": ["modifications", "changes"]}}, {"LOWER": {"IN": ["are", "do"]}, "OP": "?"}, {"LOWER": "pending", "OP": "?"}],
            [{"LOWER": {"IN": ["review", "see"]}}, {"LOWER": {"IN": ["modifications", "changes"]}}],
            [{"LOWER": "pending"}, {"LOWER": {"IN": ["modifications", "changes"]}}],
            [{"LOWER": {"IN": ["show", "display"]}}, {"LOWER": "me"}, {"LOWER": {"IN": ["modifications", "changes"]}}],
            [{"LOWER": {"IN": ["what", "which"]}}, {"LOWER": {"IN": ["changes", "modifications"]}}, {"LOWER": {"IN": ["need", "require"]}, "OP": "?"}, {"LOWER": {"IN": ["approval", "review"]}}]
        ]
        
        # Approval patterns (regular test cases)
        approve_patterns = [
            [{"LOWER": {"IN": ["approve", "accept", "keep"]}}],
            [{"LOWER": {"IN": ["yes", "good", "great", "perfect", "excellent"]}}],
            [{"LOWER": {"IN": ["looks", "look"]}}, {"LOWER": "good"}],
            [{"LOWER": "that's"}, {"LOWER": {"IN": ["good", "great", "perfect"]}}],
            [{"LOWER": {"IN": ["approve", "accept", "keep"]}}, {"LOWER": "all"}],
            [{"LOWER": "i"}, {"LOWER": "like"}, {"TEXT": {"REGEX": ".*"}, "OP": "*"}],
            [{"LOWER": {"IN": ["all", "everything"]}}, {"LOWER": {"IN": ["looks", "look"]}}, {"LOWER": "good"}]
        ]
        
        # Rejection patterns (regular test cases)
        reject_patterns = [
            [{"LOWER": {"IN": ["reject", "remove", "delete", "discard"]}}],
            [{"LOWER": {"IN": ["no", "bad", "terrible", "awful", "wrong"]}}],
            [{"LOWER": {"IN": ["don't", "dont"]}}, {"LOWER": {"IN": ["want", "like"]}}],
            [{"LOWER": "get"}, {"LOWER": "rid"}, {"LOWER": "of"}],
            [{"LOWER": {"IN": ["i", "that's"]}}, {"LOWER": {"IN": ["hate", "dislike"]}}]
        ]
        
        # Show/review patterns
        show_patterns = [
            [{"LOWER": {"IN": ["show", "display", "see", "review"]}}],
            [{"LOWER": "what"}, {"LOWER": {"IN": ["do", "did"]}, "OP": "?"}, {"LOWER": {"IN": ["we", "you"]}, "OP": "?"}, {"LOWER": "have"}],
            [{"LOWER": "let"}, {"LOWER": "me"}, {"LOWER": "see"}],
            [{"LOWER": {"IN": ["what's", "whats"]}}, {"LOWER": {"IN": ["there", "pending", "generated"]}}],
            [{"LOWER": {"IN": ["review", "check"]}}, {"LOWER": {"IN": ["tests", "cases"]}, "OP": "?"}]
        ]
        
        # Show all patterns
        show_all_patterns = [
            [{"LOWER": "show"}, {"LOWER": "all"}],
            [{"LOWER": "all"}, {"LOWER": {"IN": ["cases", "tests"]}}],
            [{"LOWER": {"IN": ["everything", "status", "summary"]}}],
            [{"LOWER": {"IN": ["full", "complete"]}}, {"LOWER": {"IN": ["status", "summary"]}}]
        ]
        
        # Export patterns
        export_patterns = [
            [{"LOWER": {"IN": ["export", "save", "download"]}}],
            [{"LOWER": {"IN": ["we're", "were", "i'm", "im"]}}, {"LOWER": {"IN": ["done", "finished"]}}],
            [{"LOWER": {"IN": ["create", "make"]}}, {"LOWER": {"IN": ["file", "excel"]}}],
            [{"LOWER": {"IN": ["finish", "complete", "done"]}}]
        ]
        
        # Complete field patterns
        complete_patterns = [
            [{"LOWER": {"IN": ["complete", "finish"]}}, {"LOWER": {"IN": ["field", "this"]}, "OP": "?"}],
            [{"LOWER": {"IN": ["done", "finished"]}}, {"LOWER": "with"}, {"TEXT": {"REGEX": ".*"}, "OP": "*"}],
            [{"LOWER": {"IN": ["field", "this"]}}, {"LOWER": {"IN": ["complete", "done", "finished"]}}]
        ]
        
        # Help patterns
        help_patterns = [
            [{"LOWER": "help"}],
            [{"LOWER": {"IN": ["what", "how"]}}, {"LOWER": {"IN": ["can", "do", "should"]}}, {"LOWER": "i"}],
            [{"LOWER": {"IN": ["i'm", "im"]}}, {"LOWER": {"IN": ["lost", "confused"]}}],
            [{"LOWER": "guide"}, {"LOWER": "me"}],
            [{"LOWER": {"IN": ["what", "which"]}}, {"LOWER": {"IN": ["commands", "options"]}}]
        ]
        
        # Add all patterns to matcher
        self.matcher.add("SELECT_FIELD", select_patterns)
        self.matcher.add("SEARCH_FIELD", search_patterns)
        self.matcher.add("LIST_FIELDS", list_patterns)
        self.matcher.add("GENERATE", generate_patterns)
        self.matcher.add("MORE", more_patterns)
        self.matcher.add("IMPROVE", improve_patterns)
        self.matcher.add("MODIFY_TESTCASE", modify_tc_patterns)
        self.matcher.add("APPROVE_MODIFICATION", approve_mod_patterns)
        self.matcher.add("REJECT_MODIFICATION", reject_mod_patterns)
        self.matcher.add("SHOW_MODIFICATIONS", show_mod_patterns)
        self.matcher.add("APPROVE", approve_patterns)
        self.matcher.add("REJECT", reject_patterns)
        self.matcher.add("SHOW", show_patterns)
        self.matcher.add("SHOW_ALL", show_all_patterns)
        self.matcher.add("EXPORT", export_patterns)
        self.matcher.add("COMPLETE_FIELD", complete_patterns)
        self.matcher.add("HELP", help_patterns)
    
    def parse_intent(self, user_input: str) -> tuple:
        """Parse user intent using spaCy NLP with full modification support"""
        
        if not user_input.strip():
            return 'unknown', {}
        
        user_input_clean = user_input.strip()
        user_input_lower = user_input_clean.lower()
        
        # Extract test case IDs (including modification IDs)
        tc_ids = re.findall(self.tc_id_pattern, user_input.upper())
        mod_ids = re.findall(self.mod_id_pattern, user_input.upper())
        all_ids = tc_ids + mod_ids
        
        # Process with spaCy
        doc = self.nlp(user_input_lower)
        matches = self.matcher(doc)
        
        if matches:
            # Sort matches by priority (modification patterns first)
            priority_labels = [
                "APPROVE_MODIFICATION", "REJECT_MODIFICATION", "SHOW_MODIFICATIONS",
                "MODIFY_TESTCASE", "APPROVE", "REJECT", "GENERATE", "MORE"
            ]
            
            # Find the highest priority match
            best_match = None
            best_priority = float('inf')
            
            for match in matches:
                match_id, start, end = match
                label = self.nlp.vocab.strings[match_id]
                
                if label in priority_labels:
                    priority = priority_labels.index(label)
                    if priority < best_priority:
                        best_priority = priority
                        best_match = match
                
                if best_match is None:
                    best_match = match
            
            match_id, start, end = best_match
            label = self.nlp.vocab.strings[match_id]
            
            # Convert spaCy label to intent
            intent_map = {
                "SELECT_FIELD": "select_field",
                "SEARCH_FIELD": "search_field", 
                "LIST_FIELDS": "list_fields",
                "GENERATE": "generate",
                "MORE": "regenerate",
                "IMPROVE": "improve",
                "MODIFY_TESTCASE": "improve",  # Routes to improve but with specific TC context
                "APPROVE": "approve",
                "REJECT": "reject",
                "SHOW": "show_pending",
                "SHOW_ALL": "show_all",
                "EXPORT": "export",
                "COMPLETE_FIELD": "complete_field",
                "HELP": "help",
                
                # MODIFICATION INTENTS
                "APPROVE_MODIFICATION": "approve_modification",
                "REJECT_MODIFICATION": "reject_modification",
                "SHOW_MODIFICATIONS": "show_modifications"
            }
            
            intent = intent_map.get(label, "unknown")
            
            # Build parameters
            params = {'tc_ids': all_ids}
            
            # Special handling for modification IDs
            if mod_ids:
                params['modification_ids'] = mod_ids
                params['is_modification_action'] = True
            
            # Extract target/context
            if label == "MODIFY_TESTCASE":
                # For test case modifications, preserve the full request
                params['target'] = user_input_clean
                params['specific_tc_modification'] = True
            else:
                # Standard target extraction
                remaining_tokens = [token.text for i, token in enumerate(doc) if i < start or i >= end]
                if remaining_tokens:
                    params['target'] = ' '.join(remaining_tokens).strip()
                elif end < len(doc):
                    params['target'] = ' '.join([token.text for token in doc[end:]]).strip()
                else:
                    params['target'] = user_input_clean
            
            # Clean up target
            if 'target' in params and params['target']:
                target = params['target']
                # Remove common stop words but preserve important context
                stop_words = {'the', 'a', 'an', 'to', 'for', 'with', 'on', 'at', 'by', 'in'}
                target_words = [word for word in target.split() if word.lower() not in stop_words or len(target.split()) <= 3]
                if target_words:
                    params['target'] = ' '.join(target_words)
            
            return intent, params
        
        # Fallback to keyword matching
        return self._keyword_fallback(user_input_lower, all_ids, user_input_clean)
    
    def _keyword_fallback(self, user_input_lower: str, all_ids: list, original_input: str) -> tuple:
        """Enhanced fallback keyword-based matching with modification support"""
        
        keywords = {
            'generate': ['generate', 'create', 'make', 'build', 'start'],
            'approve': ['approve', 'accept', 'good', 'yes', 'keep', 'like', 'perfect', 'great'],
            'reject': ['reject', 'remove', 'delete', 'bad', 'no', 'terrible', 'wrong'],
            'show_pending': ['show', 'display', 'see', 'what', 'review', 'pending'],
            'export': ['export', 'save', 'download', 'done', 'finish', 'excel', 'file'],
            'help': ['help', 'how', 'what can', 'guide', 'lost', 'confused'],
            'improve': ['improve', 'change', 'modify', 'better', 'fix', 'enhance', 'update'],
            'select_field': ['select', 'choose', 'pick', 'use', 'work on', 'field'],
            'search_field': ['search', 'find', 'look for'],
            'list_fields': ['list', 'all fields', 'available', 'options', 'show all'],
            'regenerate': ['more', 'additional', 'extra', 'again', 'regenerate'],
            
            # MODIFICATION-SPECIFIC KEYWORDS
            'approve_modification': ['approve modification', 'accept change', 'yes to modification', 'modification approved'],
            'reject_modification': ['reject modification', 'no to change', 'discard modification', 'modification rejected'],
            'show_modifications': ['show modifications', 'pending modifications', 'review changes', 'what modifications'],
            'complete_field': ['complete field', 'finish field', 'done with field', 'field complete']
        }
        
        # Special handling for modification IDs
        if any('MODIFIED' in tc_id for tc_id in all_ids):
            if any(word in user_input_lower for word in ['approve', 'accept', 'yes', 'good', 'ok', 'keep']):
                return 'approve_modification', {
                    'tc_ids': all_ids, 
                    'modification_ids': [tc_id for tc_id in all_ids if 'MODIFIED' in tc_id],
                    'target': original_input,
                    'is_modification_action': True
                }
            elif any(word in user_input_lower for word in ['reject', 'no', 'bad', 'discard', 'wrong']):
                return 'reject_modification', {
                    'tc_ids': all_ids,
                    'modification_ids': [tc_id for tc_id in all_ids if 'MODIFIED' in tc_id], 
                    'target': original_input,
                    'is_modification_action': True
                }
        
        # Count keyword matches for each intent
        intent_scores = {}
        for intent, words in keywords.items():
            score = 0
            for word in words:
                if word in user_input_lower:
                    # Give higher score for exact matches
                    if user_input_lower == word:
                        score += 3
                    else:
                        score += 1
            
            if score > 0:
                intent_scores[intent] = score
        
        # Return intent with highest score
        if intent_scores:
            best_intent = max(intent_scores.items(), key=lambda x: x[1])[0]
            
            params = {'tc_ids': all_ids, 'target': original_input, 'fallback': True}
            
            # Add modification context if relevant
            if any('MODIFIED' in tc_id for tc_id in all_ids):
                params['is_modification_action'] = True
                params['modification_ids'] = [tc_id for tc_id in all_ids if 'MODIFIED' in tc_id]
            
            return best_intent, params
        
        # Final fallback using fuzzy matching
        best_intent = self._fuzzy_match_intent(user_input_lower)
        if best_intent:
            return best_intent, {'tc_ids': all_ids, 'target': original_input, 'fuzzy': True}
        
        return 'unknown', {'raw_input': original_input, 'tc_ids': all_ids}
    
    def _fuzzy_match_intent(self, user_input: str) -> str:
        """Use fuzzy matching for intent recognition as final fallback"""
        
        intent_keywords = {
            'generate': ['generate', 'create', 'make', 'build'],
            'approve': ['approve', 'accept', 'yes', 'good', 'keep'],
            'reject': ['reject', 'no', 'bad', 'remove', 'delete'],
            'export': ['export', 'save', 'download', 'excel'],
            'show_pending': ['show', 'display', 'review', 'see'],
            'help': ['help', 'commands', 'how'],
            'improve': ['improve', 'change', 'modify', 'better'],
            'select_field': ['select', 'choose', 'field'],
            'regenerate': ['more', 'additional', 'again']
        }

        best_match = None
        best_score = 0.6  # Minimum similarity threshold

        for intent, keywords in intent_keywords.items():
            for keyword in keywords:
                similarity = SequenceMatcher(None, user_input, keyword).ratio()
                if similarity > best_score:
                    best_score = similarity
                    best_match = intent

        return best_match
